Non -Generic 

boxing/unboxing
boxing :- When we convert a value type(like int ) into an object type(reference type)

int num value1 = 10;
object boxedvalue = num;  // boxing

Unboxing  :-  when we extract the value type from an object

int valuetype = (int)boxedvalue;  // unboxing

These operations are expensive in performance :- then there will be a memory overhead  ,
  This one is non type-safe because by mistaken wrong casting can be done which may cause a run time errors

  List<Student> list = new List<Student>();

  for(int i=0 ; i<5 ; i++)
  {
    Student s = new Student(3434,"df");
     list.Add(s);
  }

  List<int> numbers = new List<int>();
  numbers.Add(10);  // No boxing
  int result = numbers[0]; // No Unboxing
 
 // Non-Generic
  List numbers = new List();
  numbers.Add(10);  // No boxing
  int result = numbers[0]; // No Unboxing

  c# provides some wrapper classes 

  Wrapper class is a class that wraps value types to provide some extra functionalities
  System.Object which is the universal 

  System.Int32 -- wraps -- value type which is int  -- Generic class for type safety at compile time only you are telling to compiler that internally should convert into int
  System.Double -- wraps -- value type which is Double
  Whenever we are boxing to an int ,  it is converting it into System.Object but internally it uses System.Int32;


// See https://aka.ms/new-console-template for more information
using System.Collections;
class NonGenericExample
{

    static void Main()
    {
        // int num = 45;
        // object boxedvalue = num; //Boxing

        // Console.WriteLine(boxedvalue.GetType());

        ArrayList arrayList = new ArrayList();  // It will store the values in object
        int value = 20;

        arrayList.Add(value); // Boxing
        Console.WriteLine(arrayList.GetType());

        double unboxingvalue = (double)arrayList[0]; // Unboxing

        Console.WriteLine("The value after unboxing " + unboxingvalue);

        //Generic one
        List<int> intList = new List<int>();
        intList.Add(value); // No Boxing is required
         double value2 = intList[0]; // No unBoxing is required
          Console.WriteLine("The value after unboxing " + value2);
    }


}


File Handling -- 

Input Stream & Output Stream

Stream -- It is an representation of a sequence of data or bytes that flows from one direction to another

Console.ReadLine(); -- > Input stream -- Keyboard

 Stream or a pipe (where your data flows) -- save your data into a file. ( File input stream(Reading) and File output stream(Writing))

Console.WriteLine(); --> Output Stream -- output devices  -- Monitor


Input Stream -- Reading the data from file or Keyboard
Output Stream --  Writing the data to a file or on Console
File Stream --- which is used to read/write to files ( file based) 
Memory Stream -- Read/ write the data in memory(RAM) not a file
Network Stream - TCP/IP  -- which will transfer the data over a network.


FileStream fs = new FileStream("datafile.txt",FileMode.Create);

Keyboard ---InputStream---> To your app ---Output Stream ----> File / Console
After this you can pass this file to 
StreamReader
StreamWriter
BinaryReader
BinaryWriter

Stream input = Console.OpenStandardInput();
StreamReader reader = new StreamReader(input);

string  line = reader.ReadLine();
Console.WriteLine(line);


Stream output = Console.OpenStandardOutput();
StreamWriter writer = new StreamWriter(output);

writer.WriteLine("this is your code");



using System.IO;


class Program2
{


    static void Main()
    {

        string path = "file1.txt";
        string message = "File data related to c#";

        //To write using FileStream
        // Garbage collector 
        // Manually we have to close and open (we need not to write manually open / close /flush with using keyword it automatically does)
        FileStream fs = new FileStream(path, FileMode.Create, FileAccess.Write);
        
            byte[] data = System.Text.Encoding.UTF8.GetBytes(message);

            fs.Write(data, 0, data.Length);

        fs.Close();

        FileStream fs1 = new FileStream(path, FileMode.Open, FileAccess.Read);
        
            // To read the data it is important to use buffer 
            byte[] buffer = new byte[fs1.Length];
            fs1.Read(buffer, 0, buffer.Length);

            string result = System.Text.Encoding.UTF8.GetString(buffer);
            Console.WriteLine(result);
            fs1.Close();
    }
}